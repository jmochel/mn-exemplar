---
globs: *.java
alwaysApply: false
title: Java General Coding Guidelines
description: General Java rules for this project
scope: project
tags: [java, guidelines, style]
priority: high
---

# Java Coding Guidelines


- Use .equals for object comparison
- Do not use Vector or Hashtable
- Use StringBuilder for composing strings 
- Only use java.time package for times and dates
- Do not use Serializable
- Do not use Boolean or boolean in parameter lists
- Use Objects.equals(x,y)
- @Override
public int hashCode() {
    return Objects.hash(id, name, email);
}
-@Override
public String toString() {
    return Objects.toString(name, "Unknown"); ?
}
- this.value = Objects.requireNonNull(value, "value is required");
- Use Collections.emptyList() Instead of new ArrayList<>() for Defaults
- Replace null Checks with Collections.singletonList()
- Prefer EnumSet Over HashSet for Enums
- Create Unmodifiable Collections with One Line: List<String> names = List.of("Alice", "Bob", "Charlie");
- Iterate with forEachRemaining on Iterators
-  Use Collectors.toUnmodifiableList() for Safe Streams: List<String> names = users.stream()
        .map(User::getName)
        .collect(Collectors.toUnmodifiableList());

- to use double brace initialization 
  - List<String> fruits = new ArrayList<>() {{
    add("Apple");
    add("Banana");
    add("Mango");
}};

- Do not use assert keyword 
- 

## Interfaces 
- USe when Multiple Implementations Exist
- Use When injecting including multiple inmpls
- Use when You’re Writing a Library or SDK


## General Principles

- Use "Effective Java 3rd Edition" as the primary coding guidelines
- Prefer immutability wherever possible.
- Apply SOLID principles but do not apply Interface Segregatioon

## Naming Things

- Use meaningful names (no abbreviations). Standard acronyms are used in the same case as they are defined (i.e.XML is all caps)
- Do not use the meaningless suffixes: Helper, Utils, Manager, Data, 
- Use business domain nouns and verbs. A method should do something, and its name should say so
- 

## Handling No-Things

- Do not initialize variables to null
- Do not return nulls, return Optional or empty collections instead
- Option1: Return Optional<T> for Explicit Absence
-  Option2: Don’t use Optional In DTOs or method parameters (especially in performance-critical code).
-  Option3: Return a Default or Empty Object (The Null Object Pattern)

## Javadoc Comments

- Comments Explain “Why”, Not “What”
- 

## Contructors and creating objects

- Use static factory methods when
  - You need a descriptive name.
  - You want to validate/invariant-check before creation.
  - You want to return a cached, shared, or flyweight instance.
  - You want to control or hide the concrete type.
  - You need subtype selection.
  - You want to vary the returned object per input or environment.
  - You want better type inference or generic helpers.
  - You want singletons or scoped lifecycles.
  - You want expressive conversions.
  - You need API stability across versions.
  - You’re wrapping records.
- Use constructors when
  - You want the simplest, most discoverable API for “just build the thing.”
- Use builders when faced with many constructor parameters
- Enforce the singleton property with a private constructor or an enum type
- 
## Enumerations

- Use enumerations instead of constants for ....????
- Frameworks/reflection require a no-arg or visible constructor.
- You explicitly support subclassing by users.
- You want constructor method references.
- You don’t need any of the flexibility above.

## Value Objects

## Exceptions

## Try Catch

- Use try with resources

## Streams

- Use filter() Before map() to Avoid Nulls
- Use peek() for Debugging (But Don’t Leave It In)
- 



## Java 11 or greater

- Use `var` for local variables whenever possible

## Java 17 or greater


- Make variables `final` whenever possible
- Use records for immutable DTS or Value Objects
- Switch Expressions
- Records
- ??? USe sealed classes and pattern matching  ????
- Multiline Text Blocks: Multiline String Sanity
- 

## Java 21 or greater 

- ??? Virtual Threads 
- pattern matching for switch ????
- Record Patterns


## Java 24 or greater

- MArkdown Javadoc
- Primitive types in patterns
- Nullabel vs non-nullable value types

- Look into  CRaC: Instant App Startup : CRaC (Coordinated Restore at Checkpoint) lets you freeze a running JVM and restore it instantly — perfect for cloud scaling and serverless.
✅ Faster cold starts
✅ Lower cloud cost
✅ Better autoscaling

- Pattern matching in switch, records, sealed classes, 
like 
```java
switch (shape) {
    case Circle c -> area = Math.PI * c.r * c.r;
    case Square s -> area = s.side * s.side;
    default -> throw new IllegalArgumentException();
}
```
- Sequenced Collections

```java
list.getFirst();
list.getLast();
list.removeFirst();
list.removeLast();
```

- UTF-8 as Default Charset

-  Scoped Values - A safer alternative to ThreadLocal.

✅ Immutable
✅ Fast
✅ Perfect for context passing in async code

```java
ScopedValue<String> USER = ScopedValue.newInstance();

ScopedValue.where(USER, "Sumit").run(() -> {
    System.out.println(USER.get()); // Sumit
});
```

- Enhanced Records & Sealed Classes
The combo of sealed + records gives Java a powerful type system:

```java
sealed interface Payment permits UPI, Card {}
record UPI(String id) implements Payment {}
record Card(String number) implements Payment {}
```


